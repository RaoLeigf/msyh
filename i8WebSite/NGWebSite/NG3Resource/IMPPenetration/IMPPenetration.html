
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>dragNode</title>
    <style type="text/css">
        #holder {
            top: 0px;
            left: 0px;
            right: 0px;
            bottom: 0px;
            position: absolute;
            z-index: 999;
            /*overflow-x:hidden;
            overflow-y:hidden;*/
        }

        .nodeText {
            position: absolute;
            /*width: 75px;*/
            width: 90px;
            height: 18px;
            /*height: 36px;*/
            top: 0px;
            z-index: 0;
            font-size: 5px;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }
    </style>


</head>

<body>
    <div id="holder">
    </div>
</body>

<script language="javascript" type="text/javascript" src="../../NG3Resource/raphael-master/node_modules/jquery/dist/jquery.js"></script>
<script language="javascript" type="text/javascript" src="../../NG3Resource/raphael-master/raphael.js"></script>
<script type="text/javascript">
            var r;//画布
            var shapes = [];//存储节点

            var upNodeObjectArray;//上追 二维对象数组
            var downNodeObjectArray;//下查 二维对象数组

            var upConnections = []; //用来存储连线
            var downConnections = [];

            var rootObj;

            function NodeObject(param, parent, type, x, y, width, height,group) {
                this.id = guid();
                this.text = param.text;
                this.sourceui = param.sourceui;
                this.sourcepkitem = param.sourcepkitem;
                this.sourcepkvalue = param.sourcepkvalue;
                this.editurl = param.editurl;
                this.targetui = param.targetui;
                this.targetpkitem = param.targetpkitem;                
                this.targetpkvalue = param.targetpkvalue;                
                this.containertype = param.containertype;
                this.buscode = param.buscode;
                this.schemephid = param.schemephid;
                if (type == 'up') {
                    this.temppkitem = param.sourcepkitem;
                    this.temppkvalue = param.sourcepkvalue;
                } else {
                    this.temppkitem = param.targetpkitem;
                    this.temppkvalue = param.targetpkvalue;
                }

                this.parent = parent;
                this.child = null;
                this.type = type;
                //this.layer = (type == 'up') ? parent.layer-- : parent.layer++;
                this.layer = parent.layer+1;
                this.expand = false;
                this.hasExpand = false;
                this.group = group;//当前块的容器群

                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;

                this.shape = r.rect(this.x, this.y, this.width, this.height);//?构造函数可以直接使用全局变量吗？
                this.shape.attr({ fill: '#EE9611', stroke: '#EE9611', "fill-opacity": 0, "stroke-width": 0, cursor: "pointer" });
                this.shape.identity = this;
                this.shape.id = this.id;

                this.shape.dblclick(function () {
                    var tempObj = this.identity;
                    var param = (tempObj.type == 'up' ? ('id=' + tempObj.sourcepkvalue) : ('id=' + tempObj.targetpkvalue));
                    param += '&containertype=' + tempObj.containertype;
                    param += '&otype=view&schemephid=' + tempObj.schemephid;
                    if (tempObj.editurl != '' && tempObj.editurl != null) {
                        window.parent.openNodeUrl(tempObj.text, tempObj.editurl, param);
                    }
                })



                this.horizontal = r.path('M' + (x + 5) + ',' + (y + 10) + ' L' + (x + 15) + ',' + (y + 10) + ' z').attr("stroke-width", 2);;
                this.vertical = r.path('M' + (x + 10) + ',' + (y + 5) + ' L' + (x + 10) + ',' + (y + 15) + ' z').attr("stroke-width", 2);;
                this.btnCircle = r.circle(x + 10, y + 10, 10);

                //this.btnCircle.attr({ fill: '#EE9611', stroke: '#EE9611', "fill-opacity": .6, "stroke-width": 2, cursor: "pointer" });
                this.btnCircle.attr({ fill: '#EE9611', stroke: '#EE9611', "fill-opacity": .0, "stroke-width": 0, cursor: "pointer" });
                this.btnCircle.id = this.id;
                this.btnCircle.identity = this;
                this.btnCircle.horizontal = this.horizontal;
                this.btnCircle.vertical = this.vertical;
                this.btnCircle.click(function () {

                    var identityObj = this.identity;
                    if (identityObj.expand) {
                        identityObj.expand = !identityObj.expand;
                        hideChild(identityObj.group);
                        //this.animate({ "fill-opacity": .6 }, 50);
                        this.vertical.attr("stroke-width", 1);
                    } else {
                        identityObj.expand = !identityObj.expand;
                        //先隐藏兄弟节点的子树，再展开自己的子树
                        var brother;
                        //根节点有左右子树之分，在此处要特殊判断
                        if (identityObj.parent.type == 'root') {
                            if (identityObj.type == 'up') {
                                brother = identityObj.parent.upChild;
                            } else {
                                brother = identityObj.parent.downChild;
                            }
                            if (brother != null && brother.length > 0) {
                                for (var i = 0; i < brother.length; i++) {
                                    hideChild(brother[i]);
                                }
                            }
                        } else {
                            brother = identityObj.parent.child;
                            if (brother != null && brother.length > 0) {
                                for (var i = 0; i < brother.length; i++) {
                                    for (var j = 0; j < brother[i].length; j++) {
                                        hideChild(brother[i][j]);
                                    }
                                }
                            }
                        }
                        hideChild(identityObj.group);

                        //if (identityObj.parent.type != 'root') {
                        //    var objGroup = identityObj.parent;
                        //    hideChild(objGroup);
                        //}

                        //判断子树是否已被创建，继而决定是新建还是显示子树
                        if (identityObj.hasExpand == false) {
                            lookUpOrDown(identityObj.buscode, identityObj.temppkitem, identityObj.temppkvalue, type, identityObj.group, identityObj);
                            identityObj.hasExpand = true;
                            identityObj.expand = true;
                            identityObj.group.hasExpand = true;
                            identityObj.group.expand = true;
                        } else {
                            showChild(identityObj);
                            identityObj.expand = true;
                            identityObj.group.expand = true;
                        }
                        //this.animate({ "fill-opacity": 0 }, 50);
                        this.vertical.attr("stroke-width", 0);
                    }
                })



                var tempDiv = document.createElement('div');
                tempDiv.innerHTML = nameIntercept(this.text);
                tempDiv.id = this.id;
                tempDiv.className = "nodeText";
                tempDiv.style.fontSize = '5px';
                document.body.appendChild(tempDiv);
                $("#" + tempDiv.id).offset({ top: y + 5, left: x + 20 });
                this.div = tempDiv;
            }

            function TitleNodeObj(param, parent, type, x, y, width, height, group) {
                this.id = guid();
                this.group = group;
                this.text = group.busname;

                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.shape = r.rect(this.x, this.y, this.width, this.height);//?构造函数可以直接使用全局变量吗？
                this.shape.attr({ fill: '#EE9611', stroke: '#EE9611', "fill-opacity": 0, "stroke-width": 2, cursor: "pointer" });
                this.shape.identity = this;
                this.shape.id = this.id;

                var tempDiv = document.createElement('div');
                tempDiv.innerHTML = nameIntercept(this.text);
                tempDiv.id = this.id;
                tempDiv.className = "nodeText";
                tempDiv.style.fontSize = '5px';
                document.body.appendChild(tempDiv);
                $("#" + tempDiv.id).offset({ top: y + 5, left: x + 5 });
                this.div = tempDiv;
            }

            function NodeObjectGroup(param, parent, type, x, y, width, height) {
                this.id = guid();
                this.busname = param[0].busname;
                this.buscode = param[0].buscode;

                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height * (param.length + 1);
                this.shape = r.rect(this.x, this.y, this.width, this.height);//?构造函数可以直接使用全局变量吗？
                this.shape.attr({ fill: '#EE9611', stroke: '#EE9611', "fill-opacity": 0, "stroke-width": 2, cursor: "pointer" });
                this.shape.identity = this;
                this.shape.id = this.id;

                this.nodeObj = new Array();
                var tempY;
                var titleNodeObj = new TitleNodeObj(param, parent, type, x, y, width, height, this);
                this.nodeObj.push(titleNodeObj);
                for (var i = 0; i < param.length; i++) {
                    tempY = y + height * (i + 1);
                    var obj = new NodeObject(param[i], parent, type, x, tempY, width, height, this);
                    this.nodeObj.push(obj);
                }

                this.parent = parent;
                this.child = null;
                this.type = type;
                //this.layer = (type == 'up') ? parent.layer-- : parent.layer++;
                this.layer = parent.layer + 1;
                this.expand = false;
                this.hasExpand = false;
            }

            $(function () {
                //创建绘图对象
                r = Raphael("holder", $(window).width(), $(window).height());
                upConnections = new Array();
                downConnections = new Array();
                var param = window.parent.load();
                //var param = new Object();
                //buscode=CG_REQ&sourcepkitem=PhId&sourcepkvalue=644180307000004&_dc=1520582540564&node=root
                //param.buscode = "CG_REQ";
                //param.text = "测试单据";
                //param.temppkitem = "PhId";
                //param.temppkvalue = "644180307000004";

                //buscode=CG_PLAN&targetpkitem=PhId&targetpkvalue=522180308000002&_dc=1521007439875&node=root
                //param.buscode = "CG_PLAN";
                //param.text = "测试单据";
                //param.temppkitem = "PhId";
                //param.temppkvalue = "522180308000002";

                //buscode=CG_REQ&targetpkitem=PhId&targetpkvalue=522180314000001&_dc=1521013467952&node=root
                //param.buscode = "CG_REQ";
                //param.text = "测试单据";
                //param.temppkitem = "PhId";
                //param.temppkvalue = "522180314000001";

                upNodeObjectArray = new Array();//上追 二维对象数组
                downNodeObjectArray = new Array();//下查 二维对象数组

                var upNodeObjects_0 = new Array();
                var downNodeObjects_0 = new Array();
                rootObj = new Object();

                upNodeObjects_0.push(rootObj);
                downNodeObjects_0.push(rootObj);

                upNodeObjectArray.push(upNodeObjects_0);
                downNodeObjectArray.push(downNodeObjects_0);

                rootObj.id = guid();
                rootObj.text = param.text;
                rootObj.buscode = param.buscode;
                rootObj.temppkitem = param.temppkitem;
                rootObj.temppkvalue = param.temppkvalue;
                rootObj.upExpand = false;
                rootObj.downExpand = false;
                rootObj.layer = 0;
                rootObj.type = 'root';
                rootObj.group = rootObj;

                rootObj.x = 500;
                rootObj.y = 250;
                rootObj.width = 115;
                //rootObj.height = 40;
                rootObj.height = 20;
                rootObj.space = rootObj.width + 60;
                rootShape = r.rect(rootObj.x, rootObj.y, rootObj.width, rootObj.height);
                rootShape.id = rootObj.id;
                rootShape.attr({ fill: '#EE9611', stroke: '#EE9611', "fill-opacity": 0, "stroke-width": 2, cursor: "pointer" });
                //shapes[i].drag(move, dragger, up);
                rootObj.shape = rootShape;

                var tempDiv = document.createElement('div');
                tempDiv.innerHTML = nameIntercept(rootObj.text);
                tempDiv.id = rootObj.id;
                tempDiv.className = "nodeText";
                tempDiv.style.fontSize = '5px';
                //tempDiv.style.background-image = url('000.PNG');
                //$('body').css('background-image', 'url(000.PNG)');
                document.body.appendChild(tempDiv);
                $("#" + rootObj.id).offset({ top: rootObj.y + 5, left: rootObj.x + 5 });
                rootObj.div = tempDiv;



                var x = rootObj.x;
                var y = rootObj.y + rootObj.height;
                var horizontal = r.path('M' + (x + 5) + ',' + (y + 10) + ' L' + (x + 15) + ',' + (y + 10) + ' z');
                var vertical = r.path('M' + (x + 10) + ',' + (y + 5) + ' L' + (x + 10) + ',' + (y + 15) + ' z');


                rootUpBtn = r.circle(rootObj.x + 10, rootObj.y + rootObj.height + 10, 10);
                rootUpBtn.horizontal = horizontal;
                rootUpBtn.vertical = vertical;
                rootUpBtn.attr({ fill: '#EE9611', stroke: '#EE9611', "fill-opacity": 0, "stroke-width": 0, cursor: "pointer" });
                rootUpBtn.id = rootObj.id;
                rootObj.rootUpBtn = rootUpBtn;


                x = rootObj.x - 10 + rootObj.width - 10;
                y = rootObj.y + rootObj.height;
                horizontal = r.path('M' + (x + 5) + ',' + (y + 10) + ' L' + (x + 15) + ',' + (y + 10) + ' z');
                vertical = r.path('M' + (x + 10) + ',' + (y + 5) + ' L' + (x + 10) + ',' + (y + 15) + ' z');

                rootDownBtn = r.circle(rootObj.x - 10 + rootObj.width, rootObj.y + rootObj.height + 10, 10);
                rootDownBtn.horizontal = horizontal;
                rootDownBtn.vertical = vertical;
                rootDownBtn.attr({ fill: '#EE9611', stroke: '#EE9611', "fill-opacity": 0, "stroke-width": 0, cursor: "pointer" });
                rootDownBtn.id = rootObj.id;
                rootObj.rootDownBtn = rootDownBtn;


                rootUpBtn.click(function () {
                    if (rootObj.upExpand) {
                        //rootObj.upExpand = !rootObj.upExpand;
                        //this.animate({ "fill-opacity": .6 }, 50);
                    } else {
                        rootObj.upExpand = !rootObj.upExpand;
                        //this.animate({ "fill-opacity": 0 }, 50);
                        this.vertical.attr("stroke-width", 0);
                        lookUpOrDown(rootObj.buscode, rootObj.temppkitem, rootObj.temppkvalue, 'up', rootObj);
                    }
                })

                rootDownBtn.click(function () {
                    if (rootObj.downExpand) {
                        //rootObj.downExpand = !rootObj.downExpand;
                        //this.animate({ "fill-opacity": .6 }, 50);
                    } else {
                        rootObj.downExpand = !rootObj.downExpand;
                        //this.animate({ "fill-opacity": 0 }, 50);
                        this.vertical.attr("stroke-width", 0);
                        lookUpOrDown(rootObj.buscode, rootObj.temppkitem, rootObj.temppkvalue, 'down', rootObj);
                    }
                })
            });

            //parent是父节点组,shape是直接的父节点
            function lookUpOrDown(buscode, temppkitem, temppkvalue, type, parent, nodeObj) {
                //param.buscode = "CG_REQ";
                //param.text = "测试单据";
                //param.temppkitem = "PhId";
                //param.temppkvalue = "522180314000001";
                //buscode = "CG_REQ";
                //type = "up";
                //temppkitem = "PhId";
                //temppkvalue = "522180314000001";
                var param = window.parent.lookUpDown(buscode, temppkitem, temppkvalue, type);
                buildChildTree(param, type, parent, nodeObj);
            }

            function buildChildTree(param, type, parent, nodeObj) {

                var nodeObjects = (type == 'up') ? upNodeObjectArray : downNodeObjectArray;
                var lowerNodeObjects;
                //判断二维数组是否已经存在该层节点，新建or直接用
                if(nodeObjects.length<parent.layer+2){
                    lowerNodeObjects = new Array();
                    nodeObjects.push(lowerNodeObjects);
                }else{
                    lowerNodeObjects = nodeObjects[parent.layer+1];
                }

                var connections = (type == 'up') ? upConnections : downConnections;
                var lowerConnections;
                //判断二维数组是否已经存在该层连线，新建or直接用
                if (connections.length < parent.layer + 1) {
                    lowerConnections = new Array();
                    connections.push(lowerConnections);
                } else {
                    lowerConnections = connections[parent.layer];
                }

                //按业务类型，把参数分类，存入二维数组
                var tempParam;
                var existFlag = false;
                for (var i = 0; i < param.length; i++) {
                    existFlag = false;
                    if (i == 0) {
                        tempParam = new Array();
                        var tempParam_0 = new Array();
                        tempParam_0.push(param[0]);
                        tempParam.push(tempParam_0);
                    } else {
                        for (var l = 0; l < tempParam.length; l++) {
                            if (tempParam[l][0].buscode == param[i].buscode) {
                                tempParam[l].push(param[i]);
                                existFlag = true;
                            }
                        }
                        if (!existFlag) {
                            var tempParam_x = new Array();
                            tempParam_x.push(param[i]);
                            tempParam.push(tempParam_x);
                        }
                    }
                }
                param = tempParam;

                var child = new Array();
                var x = 0;
                var y = 0;
                var width = rootObj.width;
                var height = rootObj.height;
                var space = rootObj.space;
                var maxHeight = 0;
                parent.x = parent.shape.attrs.x;
                parent.y = parent.shape.attrs.y;
                if (param == null || param.length == 0) {
                    return;
                }

                for (var i = 0; i < param.length; i++) {
                    if (param[i].length > maxHeight)
                        maxHeight = param[i].length;
                }
                maxHeight = maxHeight * (rootObj.height + 1);

                var increment = 500;
                //计算节点块的x坐标
                if (type == 'up') {
                    x = parent.x - space;
                } else {
                    x = parent.x + space;
                }

                //当图形 x坐标 超出画布时，扩大画布
                if (x + width > r.width) {
                    r.setSize(r.width + increment, r.height);
                }
                //当 x坐标 左边超出边界，先扩大画布再整体右移
                if (x < 0) {
                    x += increment;

                    r.setSize(r.width + increment, r.height);
                    //先处理根节点
                    rootObj.shape.attr({ x: rootObj.shape.attrs.x + increment });
                    rootObj.rootUpBtn.attr({ x: rootObj.rootUpBtn.attrs.cx + increment });
                    rootObj.rootUpBtn.horizontal.translate(increment, 0);
                    rootObj.rootUpBtn.vertical.translate(increment, 0);
                    rootObj.rootDownBtn.attr({ x: rootObj.rootDownBtn.attrs.cx + increment });
                    rootObj.rootDownBtn.horizontal.translate(increment,0);
                    rootObj.rootDownBtn.vertical.translate(increment, 0);
                    //rootObj.div.style.left = rootObj.div.offsetLeft - 8 + increment + 'px';
                    //根节点div错位
                    rootObj.div.style.left = rootObj.div.offsetLeft + increment + 'px';

                    if (upNodeObjectArray != null && upNodeObjectArray.length > 0) {
                        //根节点的数据结构不同，单独处理，这里从第一层开始
                        //先遍历上查节点组
                        for (var i = 1; i < upNodeObjectArray.length; i++) {
                            var nodeObjInUpArray = upNodeObjectArray[i];
                            if (nodeObjInUpArray != null && nodeObjInUpArray.length > 0) {
                                for (var j = 0; j < nodeObjInUpArray.length; j++) {
                                    //二维数组存的是nodeGroup对象
                                    var nodeGrp = nodeObjInUpArray[j];
                                    nodeGrp.shape.attr({ x: nodeGrp.shape.attrs.x + increment });
                                    if (nodeGrp.nodeObj != 0 && nodeGrp.nodeObj.length > 0) {
                                        var nodeTitle = nodeGrp.nodeObj[0];
                                        nodeTitle.shape.attr({ x: nodeTitle.shape.attrs.x + increment });
                                        //nodeTitle.div.style.left = nodeTitle.div.offsetLeft - 8 + increment + 'px';
                                        //！！！当div隐藏时取不到左边距，导致div平移错位，使用先显示div再平移
                                        if (nodeTitle.div.style.display == 'none') {
                                            nodeTitle.div.style.display = 'block';
                                            nodeTitle.div.style.left = nodeTitle.div.offsetLeft + increment + 'px';
                                            nodeTitle.div.style.display = 'none';
                                        } else {
                                            nodeTitle.div.style.left = nodeTitle.div.offsetLeft + increment + 'px';
                                        }
                                        //nodeGroup里第一个是标题shape，单独处理
                                        for (var k = 1; k < nodeGrp.nodeObj.length; k++) {
                                            var node = nodeGrp.nodeObj[k];
                                            node.shape.attr({ x: node.shape.attrs.x + increment });
                                            node.btnCircle.attr({ cx: node.btnCircle.attrs.cx + increment });
                                            node.btnCircle.horizontal.translate(increment, 0);
                                            node.btnCircle.vertical.translate(increment, 0);
                                            //node.div.style.left = node.div.offsetLeft - 8 + increment + 'px';
                                            if (node.div.style.display == 'none') {
                                                node.div.style.display = 'block';
                                                node.div.style.left = node.div.offsetLeft + increment + 'px';
                                                node.div.style.display = 'none';
                                            } else {
                                                node.div.style.left = node.div.offsetLeft + increment + 'px';
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    if (downNodeObjectArray != null && downNodeObjectArray.length > 0) {
                        //再遍历下查节点组
                        for (var i = 1; i < downNodeObjectArray.length; i++) {
                            var nodeObjInDownArray = downNodeObjectArray[i];
                            if (nodeObjInDownArray != null && nodeObjInDownArray.length > 0) {
                                for (var j = 0; j < nodeObjInDownArray.length; j++) {
                                    //二维数组存的是nodeGroup对象
                                    var nodeGrp = nodeObjInDownArray[j];
                                    nodeGrp.shape.attr({ x: nodeGrp.shape.attrs.x + increment });
                                    if (nodeGrp.nodeObj != 0 && nodeGrp.nodeObj.length > 0) {
                                        var nodeTitle = nodeGrp.nodeObj[0];
                                        nodeTitle.shape.attr({ x: nodeTitle.shape.attrs.x + increment });
                                        //nodeTitle.div.style.left = nodeTitle.div.offsetLeft - 8 + increment + 'px';
                                        if (nodeTitle.div.style.display == 'none') {
                                            nodeTitle.div.style.display = 'block';
                                            nodeTitle.div.style.left = nodeTitle.div.offsetLeft + increment + 'px';
                                            nodeTitle.div.style.display = 'none';
                                        } else {
                                            nodeTitle.div.style.left = nodeTitle.div.offsetLeft + increment + 'px';
                                        }
                                        //nodeGroup里第一个是标题shape，单独处理
                                        for (var k = 1; k < nodeGrp.nodeObj.length; k++) {
                                            var node = nodeGrp.nodeObj[k];
                                            node.shape.attr({ x: node.shape.attrs.x + increment });
                                            node.btnCircle.attr({ cx: node.btnCircle.attrs.cx + increment });
                                            node.btnCircle.horizontal.translate(increment, 0);
                                            node.btnCircle.vertical.translate(increment, 0);
                                            //node.div.style.left = node.div.offsetLeft - 8 + increment + 'px';
                                            if (node.div.style.display == 'none') {
                                                node.div.style.display = 'block';
                                                node.div.style.left = node.div.offsetLeft + increment + 'px';
                                                node.div.style.display = 'none';
                                            } else {
                                                node.div.style.left = node.div.offsetLeft + increment + 'px';
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }

                    //再重新画线
                    for (var i = 0; i < upConnections.length; i++) {
                        var lenArray = upConnections[i];
                        if (lenArray != null && lenArray.length > 0) {
                            for (var j = 0; j < lenArray.length; j++) {
                                r.drawArr(lenArray[j]);
                            }
                        }
                    }
                    for (var i = 0; i < downConnections.length; i++) {
                        var lenArray = downConnections[i];
                        if (lenArray != null && lenArray.length > 0) {
                            for (var j = 0; j < lenArray.length; j++) {
                                r.drawArr(lenArray[j]);
                            }
                        }
                    }
                }

                //先计算要展开的节点的y坐标，取出最大和最小y坐标，判断是否需要扩展画布
                increment = 300;
                var maxY, minY;
                if (param.length % 2 == 0) {
                    minY = parent.y + height + (height + maxHeight) * (param.length / 2 - param.length) - param[param.length / 2].length * height / 2;
                    maxY = parent.y + height + (height + maxHeight) * (param.length / 2 - (1)) - param[param.length / 2].length * height / 2 + param[0] * height;
                } else {
                    if (parent.type == 'root') {
                        minY = parent.y + (height + maxHeight) * ((param.length - 1) / 2 - param.length+1) - param[(param.length - 1) / 2].length * height / 2;
                        maxY = parent.y + (height + maxHeight) * ((param.length - 1) / 2 - 0) - param[(param.length - 1) / 2].length * height / 2 + param[0] * height;
                    } else {
                        minY = parent.y + (height + maxHeight) * ((param.length - 1) / 2 - param.length + 1) - (param[(param.length - 1) / 2].length + 1 - parent.nodeObj.length) / 2 * height;
                        maxY = parent.y + (height + maxHeight) * ((param.length - 1) / 2 - 0) - (param[(param.length - 1) / 2].length + 1 - parent.nodeObj.length) / 2 * height + param[0] * height;
                    }
                }

                //如果需要，先扩展画布
                if (maxY > r.height) {
                    r.setSize(r.width, r.height + increment);
                }
                if (minY < 0) {

                    r.setSize(r.width, r.height + increment);
                    //先处理根节点
                    rootObj.shape.attr({ y: rootObj.shape.attrs.y + increment });
                    rootObj.rootUpBtn.attr({ y: rootObj.rootUpBtn.attrs.cy + increment });
                    rootObj.rootUpBtn.horizontal.translate(0, increment);
                    rootObj.rootUpBtn.vertical.translate(0, increment);
                    rootObj.rootDownBtn.attr({ y: rootObj.rootDownBtn.attrs.cy + increment });
                    rootObj.rootDownBtn.horizontal.translate(0, increment);
                    rootObj.rootDownBtn.vertical.translate(0, increment);
                    //rootObj.div.style.top = rootObj.div.offsetTop - 8 + increment + 'px';
                    //根节点div错位
                    rootObj.div.style.top = rootObj.div.offsetTop + increment + 'px';

                    if (upNodeObjectArray != null && upNodeObjectArray.length > 0) {
                        //根节点的数据结构不同，单独处理，这里从第一层开始
                        //先遍历上查节点组
                        for (var i = 1; i < upNodeObjectArray.length; i++) {
                            var nodeObjInUpArray = upNodeObjectArray[i];
                            if (nodeObjInUpArray != null && nodeObjInUpArray.length > 0) {
                                for (var j = 0; j < nodeObjInUpArray.length; j++) {
                                    //二维数组存的是nodeGroup对象
                                    var nodeGrp = nodeObjInUpArray[j];
                                    nodeGrp.shape.attr({ y: nodeGrp.shape.attrs.y + increment });
                                    if (nodeGrp.nodeObj != 0 && nodeGrp.nodeObj.length > 0) {
                                        var nodeTitle = nodeGrp.nodeObj[0];
                                        nodeTitle.shape.attr({ y: nodeTitle.shape.attrs.y + increment });
                                        //nodeTitle.div.style.left = nodeTitle.div.offsetLeft - 8 + increment + 'px';
                                        //nodeTitle.div.style.top = nodeTitle.div.offsetTop + increment + 'px';
                                        if (nodeTitle.div.style.display == 'none') {
                                            nodeTitle.div.style.display = 'block';
                                            nodeTitle.div.style.top = nodeTitle.div.offsetTop + increment + 'px';
                                            nodeTitle.div.style.display = 'none';
                                        } else {
                                            nodeTitle.div.style.top = nodeTitle.div.offsetTop + increment + 'px';
                                        }

                                        //nodeGroup里第一个是标题shape，单独处理
                                        for (var k = 1; k < nodeGrp.nodeObj.length; k++) {
                                            var node = nodeGrp.nodeObj[k];
                                            node.shape.attr({ y: node.shape.attrs.y + increment });
                                            node.btnCircle.attr({ cy: node.btnCircle.attrs.cy + increment });
                                            node.btnCircle.horizontal.translate(0, increment);
                                            node.btnCircle.vertical.translate(0, increment);
                                            //node.div.style.left = node.div.offsetLeft - 8 + increment + 'px';
                                            if (node.div.style.display == 'none') {
                                                node.div.style.display = 'block';
                                                node.div.style.top = node.div.offsetTop + increment + 'px';
                                                node.div.style.display = 'none';
                                            } else {
                                                node.div.style.top = node.div.offsetTop + increment + 'px';
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    if (downNodeObjectArray != null && downNodeObjectArray.length > 0) {
                        //再遍历下查节点组
                        for (var i = 1; i < downNodeObjectArray.length; i++) {
                            var nodeObjInDownArray = downNodeObjectArray[i];
                            if (nodeObjInDownArray != null && nodeObjInDownArray.length > 0) {
                                for (var j = 0; j < nodeObjInDownArray.length; j++) {
                                    //二维数组存的是nodeGroup对象
                                    var nodeGrp = nodeObjInDownArray[j];
                                    nodeGrp.shape.attr({ y: nodeGrp.shape.attrs.y + increment });
                                    if (nodeGrp.nodeObj != 0 && nodeGrp.nodeObj.length > 0) {
                                        var nodeTitle = nodeGrp.nodeObj[0];
                                        nodeTitle.shape.attr({ y: nodeTitle.shape.attrs.y + increment });
                                        //nodeTitle.div.style.left = nodeTitle.div.offsetLeft - 8 + increment + 'px';
                                        if (nodeTitle.div.style.display == 'none') {
                                            nodeTitle.div.style.display = 'block';
                                            nodeTitle.div.style.top = nodeTitle.div.offsetTop + increment + 'px';
                                            nodeTitle.div.style.display = 'none';
                                        } else {
                                            nodeTitle.div.style.top = nodeTitle.div.offsetTop + increment + 'px';
                                        }
                                        //nodeGroup里第一个是标题shape，单独处理
                                        for (var k = 1; k < nodeGrp.nodeObj.length; k++) {
                                            var node = nodeGrp.nodeObj[k];
                                            node.shape.attr({ y: node.shape.attrs.y + increment });
                                            node.btnCircle.attr({ cy: node.btnCircle.attrs.cy + increment });
                                            node.btnCircle.horizontal.translate(0, increment);
                                            node.btnCircle.vertical.translate(0, increment);
                                            //node.div.style.left = node.div.offsetLeft - 8 + increment + 'px';
                                            if (node.div.style.display == 'none') {
                                                node.div.style.display = 'block';
                                                node.div.style.top = node.div.offsetTop + increment + 'px';
                                                node.div.style.display = 'none';
                                            } else {
                                                node.div.style.top = node.div.offsetTop + increment + 'px';
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }

                    //再重新画线
                    for (var i = 0; i < upConnections.length; i++) {
                        var lenArray = upConnections[i];
                        if (lenArray != null && lenArray.length > 0) {
                            for (var j = 0; j < lenArray.length; j++) {
                                r.drawArr(lenArray[j]);
                            }
                        }
                    }
                    for (var i = 0; i < downConnections.length; i++) {
                        var lenArray = downConnections[i];
                        if (lenArray != null && lenArray.length > 0) {
                            for (var j = 0; j < lenArray.length; j++) {
                                r.drawArr(lenArray[j]);
                            }
                        }
                    }
                }


                //计算节点块的y坐标
                for (var i = 0; i < param.length; i++) {
                    if (param.length % 2 == 0) {
                        if (parent.type == 'root') {
                            y = parent.y + height + (height + maxHeight) * (param.length / 2 - (1 + i)) - param[param.length / 2].length * height / 2;
                        } else {
                            y = parent.y + height + (height + maxHeight) * (param.length / 2 - (1 + i)) - param[param.length / 2].length * height / 2;
                        }
                    } else {
                        if (parent.type == 'root') {
                            y = parent.y + (height + maxHeight) * ((param.length - 1) / 2 - i) - param[(param.length - 1) / 2].length * height / 2;
                        } else {
                            y = parent.y + (height + maxHeight) * ((param.length - 1) / 2 - i) - (param[(param.length - 1) / 2].length + 1 - parent.nodeObj.length)/2 * height;
                        }
                    }
                    //画布扩展，图像节点全体向下平移
                    if (minY < 0) {
                        y += increment;
                    }

                    var obj = new NodeObjectGroup(param[i], parent, type, x, y, width, height);
                    child.push(obj);
                    lowerNodeObjects.push(obj);
                    if (type == 'up') {
                        lowerConnections.push(r.drawArr({ obj1: obj.shape, obj2: parent.shape }));
                    } else {
                        lowerConnections.push(r.drawArr({ obj1: parent.shape, obj2: obj.shape }));
                    }
                }

                //根节点有左右子树之分，在此处要特殊判断
                if (type == 'up') {
                    if (parent.type == 'root') {
                        parent.upChild = child;
                    } else {
                        nodeObj.child = child;
                    }
                } else {
                    if (parent.type == 'root') {
                        parent.downChild = child;
                    } else {
                        nodeObj.child = child;
                    }
                }

                //!!! 单节点的儿子是节点组，这个儿子也应该是该单节点组的儿子
                if (parent.type != 'root') {
                    var objGroup = nodeObj.group;
                    if (objGroup.child == null) {
                        objGroup.child = new Array();
                    }
                    objGroup.child.push(child);
                }

            }

            function hideChild(obj) {
                var connections = (obj.type == 'up') ? upConnections : downConnections;
                var line = connections[obj.layer];
                obj.expand = false;
                //第一个是标题
                if (obj.nodeObj != null && obj.nodeObj.length > 0) {
                    for (var h = 1; h < obj.nodeObj.length; h++) {
                        //obj.nodeObj[h].btnCircle.animate({ "fill-opacity": .6 }, 50);
                        obj.nodeObj[h].btnCircle.vertical.attr("stroke-width", 1);
                        obj.nodeObj[h].expand = false;
                        var child = obj.nodeObj[h].child;

                        if (child != null && child.length > 0) {
                            for (var i = 0; i < child.length; i++) {
                                hideChild(child[i]);
                                child[i].shape.hide();
                                child[i].nodeObj[0].shape.hide();
                                child[i].nodeObj[0].div.style.display = 'none';
                                if (child[i].nodeObj != null && child[i].nodeObj.length > 0) {
                                    for (var l = 1; l < child[i].nodeObj.length; l++) {
                                        child[i].nodeObj[l].shape.hide();
                                        child[i].nodeObj[l].btnCircle.hide();
                                        child[i].nodeObj[l].btnCircle.horizontal.hide();
                                        child[i].nodeObj[l].btnCircle.vertical.hide();
                                        child[i].nodeObj[l].div.style.display = 'none';
                                    }
                                }
                            }
                        }
                    }
                }

                if (obj.type == 'up') {
                    if (line != null && line.length > 0) {
                        for (var l = 0; l < line.length; l++) {
                            if (line[l].obj2.id == obj.id) {
                                line[l].arrPath.hide()
                            }
                        }
                    }
                } else {
                    if (line != null && line.length > 0) {
                        for (var l = 0; l < line.length; l++) {
                            if (line[l].obj1.id == obj.id) {
                                line[l].arrPath.hide()
                            }
                        }
                    }
                }

            }

            function showChild(nodeObj) {
                var child = nodeObj.child;
                var connections = (nodeObj.type == 'up') ? upConnections : downConnections;
                var line = connections[nodeObj.layer];
                //nodeObj.btnCircle.animate({ "fill-opacity": 0 }, 50);
                nodeObj.btnCircle.vertical.attr("stroke-width", 0);
                nodeObj.expand = true;
                //var brother;
                ////根节点有左右子树之分，在此处要特殊判断
                //if (nodeObj.parent.type == 'root') {
                //    if (nodeObj.type == 'up') {
                //        brother = nodeObj.parent.upChild;
                //    } else {
                //        brother = nodeObj.parent.downChild;
                //    }
                //} else {
                //    brother = nodeObj.parent.child;
                //}
                //for (var i = 0; i < brother.length; i++) {
                //    hideChild(brother[i]);
                //}
                //if (child != null && child.length > 0) {
                //    for (var i = 0; i < child.length; i++) {
                //        child[i].shape.show();
                //        child[i].btnCircle.show();
                //        child[i].div.style.display = 'block';
                //        if (line != null && line.length > 0) {
                //            for (var l = 0; l < line.length; l++) {
                //                if (line[l].obj1.id == nodeObj.id) {
                //                    line[l].arrPath.show();
                //                }
                //            }
                //        }
                //    }
                //}

                if (child != null && child.length > 0) {
                    for (var i = 0; i < child.length; i++) {
                        child[i].shape.show();
                        child[i].nodeObj[0].shape.show();
                        child[i].nodeObj[0].div.style.display = 'block';
                        for (var l = 1; l < child[i].nodeObj.length; l++) {
                            child[i].nodeObj[l].shape.show();
                            child[i].nodeObj[l].btnCircle.show();
                            child[i].nodeObj[l].btnCircle.horizontal.show();
                            child[i].nodeObj[l].btnCircle.vertical.show();
                            child[i].nodeObj[l].div.style.display = 'block';
                        }
                        if (nodeObj.type == 'up') {
                            if (line != null && line.length > 0) {
                                for (var l = 0; l < line.length; l++) {
                                    if (line[l].obj1.id == child[i].id) {
                                        line[l].arrPath.show()
                                    }
                                }
                            }
                        } else {
                            if (line != null && line.length > 0) {
                                for (var l = 0; l < line.length; l++) {
                                    if (line[l].obj2.id == child[i].id) {
                                        line[l].arrPath.show()
                                    }
                                }
                            }
                        }

                    }
                }
            }


       //随着节点位置的改变动态改变箭头
        Raphael.fn.drawArr = function (obj) {
            var point = getStartEnd(obj.obj1, obj.obj2);
            var path1 = getArr(point.start.x, point.start.y, point.end.x, point.end.y, 20);

            if (obj.arrPath) {
                obj.arrPath.attr({ path: path1 });
            } else {
                obj.arrPath = this.path(path1);
            }

            obj.arrPath.attr({
                        "stroke":"#2A6570", // border color of the rectangle
                        "stroke-width":4 // the width of the border
                    });

            return obj;
        };

        function getStartEnd(obj1, obj2) {
            var bb1 = obj1.getBBox(),
                bb2 = obj2.getBBox();
            var p = [
                    //{ x: bb1.x + bb1.width / 2, y: bb1.y - 1 },
                    //{ x: bb1.x + bb1.width / 2, y: bb1.y + bb1.height + 1 },
                    { x: bb1.x - 1, y: bb1.y + bb1.height / 2 },
                    { x: bb1.x + bb1.width + 1, y: bb1.y + bb1.height / 2 },
                    { x: bb1.x - 1, y: bb1.y + bb1.height / 2 },
                    { x: bb1.x + bb1.width + 1, y: bb1.y + bb1.height / 2 },
                    //{ x: bb2.x + bb2.width / 2, y: bb2.y - 1 },
                    //{ x: bb2.x + bb2.width / 2, y: bb2.y + bb2.height + 1 },
                    { x: bb2.x - 1, y: bb2.y + bb2.height / 2 },
                    { x: bb2.x + bb2.width + 1, y: bb2.y + bb2.height / 2 },
                    { x: bb2.x - 1, y: bb2.y + bb2.height / 2 },
                    { x: bb2.x + bb2.width + 1, y: bb2.y + bb2.height / 2 }
                ];
            var d = {}, dis = [];
            for (var i = 0; i < 4; i++) {
                for (var j = 4; j < 8; j++) {
                    var dx = Math.abs(p[i].x - p[j].x),
                        dy = Math.abs(p[i].y - p[j].y);
                    if (
                         (i == j - 4) ||
                         (((i != 3 && j != 6) || p[i].x < p[j].x) &&
                         ((i != 2 && j != 7) || p[i].x > p[j].x) &&
                         ((i != 0 && j != 5) || p[i].y > p[j].y) &&
                         ((i != 1 && j != 4) || p[i].y < p[j].y))
                       ) {
                        dis.push(dx + dy);
                        d[dis[dis.length - 1]] = [i, j];
                    }
                }
            }
            if (dis.length == 0) {
                var res = [0, 4];
            } else {
                res = d[Math.min.apply(Math, dis)];
            }
            var result = {};
            result.start = {};
            result.end = {};
            result.start.x = p[res[0]].x;
            result.start.y = p[res[0]].y;
            result.end.x = p[res[1]].x;
            result.end.y = p[res[1]].y;
            return result;
        }

              //获取组成箭头的三条线段的路径
        function getArr(x1, y1, x2, y2, size) {
            var angle = Raphael.angle(x1, y1, x2, y2);//得到两点之间的角度
            var a45 = Raphael.rad(angle - 10);//角度转换成弧度
            var a45m = Raphael.rad(angle + 10);
            var x2a = x2 + Math.cos(a45) * size;
            var y2a = y2 + Math.sin(a45) * size;
            var x2b = x2 + Math.cos(a45m) * size;
            var y2b = y2 + Math.sin(a45m) * size;
            var result = ["M", x1, y1, "L", x2, y2, "L", x2a, y2a, "M", x2, y2, "L", x2b, y2b];
            return result;
        }

        //生成唯一值
        function S4() {
            return (((1 + Math.random()) * 0x10000) | 0).toString(16).substring(1);
        }
        function guid() {
            return (S4() + S4() + "-" + S4() + "-" + S4() + "-" + S4() + "-" + S4() + S4() + S4());
        }

        function getUrlParam(name) {
            var reg = new RegExp("(^|&)" + name + "=([^&]*)(&|$)");
            var r = window.location.search.substr(1).match(reg);
            if (r != null) {
                return unescape(r[2]);
            }
            return null;
        }

    //处理节点名的函数，大于八个字的名字用省略号填充
        function nameIntercept(text) {
            if (text.length > 6) {
                return text.substring(0,6)+'…';
            }
            return text;
        }
        //生成唯一值
        function S4() {
            return (((1 + Math.random()) * 0x10000) | 0).toString(16).substring(1);
        }
        function guid() {
            return (S4() + S4() + "-" + S4() + "-" + S4() + "-" + S4() + "-" + S4() + S4() + S4());
        }



</script>
</html>
